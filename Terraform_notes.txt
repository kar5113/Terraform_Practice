Terraform notes

##### Terraform Variables
1. Variables in Terraform can be defined using the `variable` block and can be referenced using `var.<variable_name>`.
2. Variables can have default values, descriptions, and types (string, number, bool, list, map, etc.).
3. Variables can be overridden using command-line flags, environment variables, or `.tfvars` files.
4. Using variables enhances the reusability and flexibility of Terraform configurations.
5. To get the variables input from the user during runtime, we can define variables without default values.
Example:
```hcl
variable "sg_name" {
  description = "Name of the security group"
  type        = string
}
##
using commmand line  example:
terraform apply -var="sg_name=custom-sg" -var="sg_port=8080" -var='sg_cidr=["0.0.0.0/0"]'
##
using tfvars file example:
Create a file named `custom.tfvars` with the following content:
sg_name = "custom-sg"
sg_port = 8080
sg_cidr = ["0.0.0.0/0"]
Then run:
terraform apply -var-file="custom.tfvars"
## 
using environment variables example:
Set environment variables with the `TF_VAR_` prefix:
export TF_VAR_sg_name="custom-sg"
export TF_VAR_sg_port=8080
export TF_VAR_sg_cidr='["0.0.0.0/0"]'
Then run:
terraform apply 
##
the order of precedence for variable values is:
1. Command-line flags
2. Environment variables
3. `.tfvars` files
4. Default values in the configuration
5. Prompted input during runtime

#### Terraform conditions

1. Terraform supports conditional expressions using the `condition ? true_value : false_value` syntax.
2. Conditional expressions can be used to set variable values, resource attributes, and module inputs based on certain conditions.
3. This allows for dynamic configurations that can adapt based on the environment or other factors.
4. Conditional expressions can be nested for more complex logic.
## Example:
```hcl
variable "environment" {
  description = "The deployment environment"
  type        = string
  default     = "dev"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = var.environment == "dev" ? "t3.micro" : "t3.large"
  tags = {
    Name = var.environment == "dev" ? "terraform-dev-instance" : "terraform-prod-instance"
  }
}
```

#### Terraform loops
1. Terraform supports looping constructs using `for` expressions and `count` meta-argument.
2. `for` expressions can be used to create lists or maps by iterating over collections.
3. The `count` meta-argument allows for the creation of multiple instances of a resource based on a specified number.
4. Loops enhance the ability to manage multiple similar resources efficiently.
## Example using `count` expression:
```hcl
variable "instance_names" {
  description = "List of instance names"
  type        = list(string)
  default     = ["instance1", "instance2", "instance3"]
}
resource "aws_instance" "example" {
  count         = length(var.instance_names)
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = var.instance_names[count.index]
  }
}
```
## Example using `for` expression:
```hcl
variable "instance_ports" {
  description = "List of instance ports"
  type        = list(number)
  default     = [80, 443, 8080]
}
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  ingress = [
    for port in var.instance_ports : {
      from_port   = port
      to_port     = port
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```
## Example for each loop: it if for both map and set 
```hcl
variable "instance_map" {
  description = "Map of instance names to AMI IDs"
  type        = map(string)
  default     = {
    "instance1" = "ami-0abcdef1234567890"
    "instance2" = "ami-0abcdef1234567891"
    "instance3" = "ami-0abcdef1234567892"
  }
}
resource "aws_instance" "example" {
  for_each      = var.instance_map
  ami           = each.value
  instance_type = "t3.micro"
  tags = {
    Name = each.key
  }
}
```

#### Data Sources in Terraform
1. Data sources in Terraform allow you to fetch and use information from external sources or existing infrastructure.
2. They are defined using the `data` block and can reference various providers to retrieve data.
3. Data sources are read-only and do not create or modify resources.
4. They are useful for obtaining information such as AMI IDs, VPC details, or other resource attributes that are needed for resource creation.
5. Data sources can be used to reference existing resources that were not created by the current Terraform configuration.
## Example:
```hcl
data "aws_ami" "example" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
resource "aws_instance" "example" {
  ami           = data.aws_ami.example.id
  instance_type = "t3.micro"
  tags = {
    Name = "terraform-example-instance"
  }
}
```


#### Functions in Terraform
1. Terraform provides a variety of built-in functions that can be used to manipulate data and perform operations within configurations.
2. Functions can be used for string manipulation, numeric calculations, type conversions, collection operations, and more.
3. Functions enhance the flexibility and dynamism of Terraform configurations by allowing for complex logic and data transformations.
4. Functions are called using the syntax `function_name(arguments)`.
5. Functions can be nested to perform multiple operations in a single expression.
## Example:
```hcl
variable "instance_name" {
  description = "Name of the instance"
  type        = string
  default     = "terraform-example-instance"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = upper(var.instance_name)
  }
}
```
various commonly used functions:
- `upper(string)`: Converts a string to uppercase. ex: upper("hello") => "HELLO"
- `lower(string)`: Converts a string to lowercase. ex: lower("HELLO") => "hello"
- `length(collection)`: Returns the length of a collection (list, map, string). ex: length(["a", "b", "c"]) => 3
- `tolist(value)`: Converts a value to a list. ex: tolist("a,b,c") => ["a", "b", "c"]
- `tomap(value)`: Converts a value to a map. ex: tomap({key1="value1", key2="value2"}) => {key1="value1", key2="value2"}
- `tostring(value)`: Converts a value to a string. ex: tostring(123) => "123"
- `join(separator, list)`: Joins a list of strings into a single string with the specified separator. ex: join("-", ["a", "b", "c"]) => "a-b-c"
- `split(separator, string)`: Splits a string into a list of substrings based on the specified separator. ex: split("-", "a-b-c") => ["a", "b", "c"]
- `lookup(map, key, default)`: Retrieves a value from a map by key, with an optional default if the key does not exist. ex: lookup({key1="value1", key2="value2"}, "key1", "default") => "value1"
- `concat(list1, list2, ...)`: Concatenates multiple lists into a single list. ex: concat(["a", "b"], ["c", "d"]) => ["a", "b", "c", "d"]
- `format(string, args...)`: Formats a string using the specified arguments.  ex: format("Hello, %s!", "World") => "Hello, World!"
- `coalesce(value1, value2, ...)`: Returns the first non-null value from the provided arguments.  data "aws_ami" "ami" {
- `merge(map1, map2, ...)`: Merges multiple maps into a single map. ex: merge({key1="value1"}, {key2="value2"}) => {key1="value1", key2="value2"}  
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}


#### Remote state with s3 backend
1. Remote state in Terraform allows you to store the state file in a remote location, enabling collaboration and state sharing among team members.  
2. The S3 backend is a popular choice for remote state storage, providing durability, availability, and access control.
3. To configure the S3 backend, you need to specify the `backend "s3"` block in your Terraform configuration, providing details such as the S3 bucket name, key (path to the state file), region, and optional settings like encryption and locking.
4. Using remote state helps prevent conflicts and ensures that all team members are working with the most up-to-date state information.
## Example:
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "6.22.1"
    }
  }
   backend "s3" {
    bucket    = "your-remote-state-bucket"
    key       = "path/to/your/terraform.tfstate"
    region    = "us-east-1"
    encrypt   = true
    use_lockfile = true
   }
}


#### Terraform Locals
1. Locals in Terraform allow you to define named values that can be reused throughout your configuration.
2. They are defined using the `locals` block and can contain expressions, calculations, or static values.
3. Locals enhance the readability and maintainability of Terraform configurations by reducing redundancy and simplifying complex expressions.
4. Locals are evaluated only once per configuration and can be referenced using the `local.<local_name>` syntax.
5. They are useful for defining commonly used values, intermediate calculations, or complex expressions that need to be reused.
## Example:
```hcl
locals {  
  instance_name = "terraform-example-instance"
  instance_tags = {
    Environment = "dev"
    Project     = "terraform-demo"
  }
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = merge(local.instance_tags, { Name = local.instance_name })
}
```
loals vs variables:
- Variables are used to accept input values from users or external sources, while locals are used to define internal values within the configuration.
- Variables can have default values and can be overridden, whereas locals are fixed once defined and cannot be changed externally.
- Variables are typically used for configuration parameters, while locals are used for derived values or reusable expressions.
- Variables cannot reference locals, but locals can reference variables. and locals cannot reference other locals. and variables cannot reference other variables.


##### Dynamic blocks in Terraform
1. Dynamic blocks in Terraform allow you to generate multiple nested blocks within a resource or module based on a collection of values.
2. They are defined using the `dynamic` block and can iterate over lists or maps to create multiple instances of a block.
3. Dynamic blocks enhance the flexibility and reusability of Terraform configurations by allowing for variable-length configurations.
4. They are useful for scenarios where the number of nested blocks is not known in advance or can vary based on input data.
5. Dynamic blocks can include `for_each` and `content` arguments to define the iteration and the content of the generated blocks.
## Example:
```hcl
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  dynamic "ingress" {
    for_each = var.ingress_ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```


#### Provisioners in Terraform
1. Provisioners in Terraform allow you to execute scripts or commands on the target resource after it has been created or before it is destroyed.
2. They are defined using the `provisioner` block within a resource and can use different types of provisioners such as `local-exec`, `remote-exec`, `file` and others.
3. Provisioners are useful for performing configuration tasks, installing software, or running custom scripts on the resource.
4. They can be configured to run only on creation, destruction, or both using the `when` argument. By default , they run on creation.
5. Provisioners should be used sparingly, as they can introduce complexity and dependencies in the Terraform lifecycle.
6. They require proper connection settings to access the target resource, such as SSH or WinRM for remote-exec provisioners.
7. It is recommended to use configuration management tools (like Ansible, Chef, Puppet) for complex provisioning tasks instead of relying heavily on Terraform provisioners.
8. The self object can be used within provisioners to reference attributes of the resource being provisioned.
## Example:
```hcl
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file(var.ssh_private_key) // Path to your private key file
      host        = self.public_ip
    }
  }
}
```

## How to create multiple environments using terraform:
1. To create multiple environments in Terraform, you can use workspaces, directory structures, or separate state files.
2. sing .tfvars files for each environment to manage different configurations.
3. You can also use modules to encapsulate common infrastructure components and reuse them across different environments

  # Refer the terrafoem-multi-env folder for working with multople env using tfvars files and directory structure.
  # or use Terraform workspaces to manage multiple environments within a single configuration.
      Terraform workspace commands:
      - terraform workspace new <workspace_name>  # Create a new workspace
      - terraform workspace select <workspace_name>  # Switch to an existing workspace
      - terraform workspace list  # List all workspaces
      - terraform workspace show  # Show the current workspace
      - terraform workspace delete <workspace_name>  # Delete a workspace
  # Create a new workspace for each environment (e.g., dev, staging, prod) and manage state files separately for each workspace.
  # now you can use terraform.workspace in the variables , look for local.tf, variables.tf file in terraform-multiple-env folder for example.    
  # terraform.workspace can be used to dynamically set values based on the current workspace. it gives the workspace name and the remote state will be stored in separate files for each workspace.
4. By following these practices, you can effectively manage multiple environments in Terraform while maintaining consistency and reusability across your infrastructure configurations.

or Maintain different repos for each environment and modules to avoid code duplication.


#### Terraform modules.
1. Modules in Terraform are reusable, self-contained packages of Terraform configurations that can be used to encapsulate and manage related resources.
2. They allow you to organize your infrastructure code into logical components, making it easier to manage, reuse, and share.
3. Modules can be created locally within your project or sourced from external repositories, such as the Terraform Registry or GitHub.
4. Using modules promotes best practices by encouraging code reuse, consistency, and modularity in your Terraform configurations.
5. Modules can accept input variables and provide output values, allowing for parameterization and data sharing between different parts of your infrastructure.
6. To use a module, you define a `module` block in your Terraform configuration, specifying the source and any required input variables.

---- Refer the terraform-module-dev folder for example module implementation. ----

#### any changes made in the module will reflect everywhere the module is used. but needs to be re initialized using terraform init command again in the root module where it is used.

    ## Advantages of using modules:
  1. Code Reusability: Modules allow you to reuse code across different projects and environments, reducing duplication and promoting consistency.
  2. Simplified Management: By encapsulating related resources, modules make it easier to manage and maintain complex infrastructure configurations.
  3. Improved Organization: Modules help organize your Terraform code into logical components, making it easier to understand and navigate.
  4. Parameterization: Modules can accept input variables, allowing for customization and flexibility in resource configurations.
  5. Collaboration: Modules facilitate collaboration among team members by providing a standardized way to define and share infrastructure components.
  6. Versioning: Modules can be versioned, allowing you to track changes and ensure compatibility across different deployments.
  7. We can implement best practices by using modules to enforce standards and guidelines for resource configurations.
  8. changes at single place will reflect everywhere the module is used -> centralised management.



### Null resource in terraform
1. The `null_resource` in Terraform is a special resource type that does not create any actual infrastructure but can be used to trigger provisioners or manage dependencies.
2. It is often used for running scripts, executing commands, or managing resources that are not directly supported by Terraform.
3. The `null_resource` can be useful for tasks such as bootstrapping, configuration management, or orchestrating actions that need to occur during the Terraform lifecycle.
4. It can be configured with provisioners like `local-exec` or `remote-exec` to run commands on the local machine or remote instances.
5. The `null_resource` can also be used to create dependencies between resources by using the `depends_on` argument.
## Example:
```hcl
resource "null_resource" "example" {
  provisioner "local-exec" {
    command = "echo 'Hello, World!' > hello.txt"
  }
}
``` 

Now null resource is deprecated, terraform-data is the new name to achieve the same functionality.


## Terraform taint
1. The `terraform taint` command is used to mark a specific resource as "tainted," indicating that it should be destroyed and recreated during the next `terraform apply`.
2. Tainting a resource is useful when you want to force the recreation of a resource due to issues, configuration changes, or to ensure a fresh state.
3. When a resource is tainted, Terraform will plan to destroy the existing resource and create a new one in its place.  
4. The command requires the resource address as an argument to specify which resource to taint.
5. After tainting a resource, you can run `terraform plan` to see the changes that will be made, followed by `terraform apply` to execute the plan and recreate the tainted resource.



#### Terraform import
1. The `terraform import` command is used to bring existing infrastructure resources under Terraform management by importing them into the Terraform state file.
2. This command allows you to manage resources that were created outside of Terraform or in a different Terraform configuration.
3. To use `terraform import`, you need to specify the resource address in your Terraform configuration and the unique identifier of the existing resource.
4. After importing, you should run `terraform plan` to ensure that the imported resource matches the desired state defined in your configuration.
5. The `terraform import` command does not create any configuration files; it only updates the state file to include the imported resource. You need to manually define the resource in your Terraform configuration to manage it going forward.
## Example:
```bash
terraform import aws_instance.example i-1234567890abcdef0
```
Then create a resource block in your configuration:
```hcl
resource "aws_instance" "example" {
  # Define the resource attributes here
  as manu as possible and match the existing resource and run terraform plan to verify
}
```

#### Terraform state commands
1. Terraform state commands are used to manage and manipulate the Terraform state file, which tracks the current state of your infrastructure.
2. Common state commands include `terraform state list`, `terraform state show`, `terraform state mv`, `terraform state rm`, and `terraform state pull`.
3. These commands allow you to view, modify, and manage resources in the state file without affecting the actual infrastructure.
4. State commands are useful for advanced scenarios, such as renaming resources, removing resources from the state, or inspecting resource attributes.
5. Proper management of the Terraform state is crucial for maintaining the integrity and consistency of your infrastructure deployments.
## Examples:
- `terraform state list`: Lists all resources in the current state file.
- `terraform state show <resource_address>`: Displays detailed information about a specific resource in the state file.
- `terraform state mv <source> <destination>`: Moves a resource from one address to another within the state file.
- `terraform state rm <resource_address>`: Removes a resource from the state file without destroying the actual resource.
- `terraform state pull`: Retrieves the current state file from the remote backend and outputs it to stdout.


#### Terraform lifecycle:
1. The `lifecycle` block in Terraform allows you to customize the behavior of resource creation, update, and deletion.
2. It provides arguments such as `create_before_destroy`, `prevent_destroy`, and `ignore_changes` to control how resources are managed during the Terraform lifecycle.
3. The `create_before_destroy` argument ensures that a new resource is created before the old one is destroyed, minimizing downtime.
4. The `prevent_destroy` argument prevents a resource from being destroyed, adding an extra layer of safety against accidental deletions.
5. The `ignore_changes` argument allows you to specify resource attributes that should be ignored during updates, preventing unnecessary changes to the resource.

While using these lifecycle blocks , its important to note the dependencies between resources to avoid conflicts or unintended consequences during the apply phase.


#### Terraform target:
1. The `-target` option in Terraform allows you to focus the execution of `terraform plan` or `terraform apply` on specific resources or modules.
2. By specifying the `-target` flag followed by the resource address, you can limit the scope of the operation to only the targeted resources.
3. This is useful for scenarios where you want to apply changes to a specific resource without affecting the rest of the infrastructure.
4. The `-target` option can help speed up the execution time by reducing the number of resources that need to be evaluated and modified.
5. However, using `-target` should be done with caution, as it can lead to inconsistencies in the overall state if dependencies are not properly managed.
## Example:
```bash
terraform apply -target=aws_instance.example
```
````bash
terraform destroy -target=aws_instance.example
```
Using this too, make a note of dependencies between resources to avoid conflicts or unintended consequences during the apply or destroy phase.

#### Terraform workspaces
1. Terraform workspaces allow you to manage multiple instances of a single Terraform configuration, enabling the creation of separate environments (e.g., dev, staging, prod) within the same configuration.
2. Each workspace has its own state file, allowing you to isolate changes and manage resources independently across different environments.
3. Workspaces can be created, selected, and deleted using the `terraform workspace`

Refer above section "How to create multiple environments using terraform" for more details on workspaces and commands.


#### Terraform CLI commands
1. `terraform init`: Initializes a Terraform working directory by downloading necessary provider plugins and setting up the backend.
2. `terraform plan`: Creates an execution plan, showing the changes that will be made to the infrastructure without applying them.
3. `terraform apply`: Applies the changes required to reach the desired state of the configuration.
4. `terraform destroy`: Destroys all resources managed by the current Terraform configuration.
5. `terraform validate`: Validates the syntax and structure of the Terraform configuration files.
6. `terraform fmt`: Formats the Terraform configuration files to follow standard conventions.
7. `terraform show`: Displays the current state or a plan in a human-readable format.
8. `terraform output`: Retrieves the values of output variables from the state file.
9. `terraform graph`: Generates a visual representation of the resource dependencies in the configuration.
10. `terraform import`: Imports existing infrastructure resources into Terraform management.
11. `terraform taint`: Marks a resource as tainted, forcing its recreation on the next apply.
12. `terraform state`: Manages the Terraform state file with various subcommands for listing, showing, moving, and removing resources.
13. `terraform workspace`: Manages multiple workspaces for different environments within the same configuration.
14. `terraform providers`: Lists the providers required by the configuration and their versions.
15. `terraform version`: Displays the current version of Terraform installed.
16. `terraform refresh`: Updates the state file to reflect the current state of the infrastructure without making any changes.
17. `terraform console`: Opens an interactive console for evaluating expressions and testing configurations.
18. `terraform login`: Authenticates with the Terraform Cloud or Enterprise to manage remote state.
19. `terraform logout`: Logs out from Terraform Cloud or Enterprise.
20. `terraform state pull`: Retrieves the current state file from the remote backend and outputs it to stdout.
21. `terraform state push`: Manually uploads a local state file to the remote backend.
22. `terraform workspace list`: Lists all available workspaces in the current configuration.
23. `terraform workspace select <workspace_name>`: Switches to the specified workspace.
24. `terraform workspace new <workspace_name>`: Creates a new workspace with the specified name.
25. `terraform workspace delete <workspace_name>`: Deletes the specified workspace. 
26. `terraform plan -target=<resource_address>`: Creates an execution plan focused on the specified resource.
27. `terraform apply -target=<resource_address>`: Applies changes only to the specified resource.
28. `terraform destroy -target=<resource_address>`: Destroys only the specified resource
29. `terraform fmt -recursive`: Formats all Terraform configuration files in the current directory and its subdirectories.
30. `terraform validate -json`: Validates the configuration and outputs the results in JSON format



#### Working with multiple providers in Terraform
1. Terraform allows you to work with multiple providers within a single configuration by defining each provider with a unique alias.
2. You can specify different configurations for each provider, such as different regions, credentials, or endpoints.
3. To use multiple providers, you need to define each provider block with an `alias` argument and reference the aliased provider in the resource blocks.
4. This feature is useful for managing resources across different cloud platforms or accounts within the same Terraform configuration.
5. Proper management of provider configurations and aliases is essential to avoid conflicts and ensure that resources are created in the correct context.
## Example:
```hcl
provider "aws" {
  region = "us-east-1"
  alias  = "us_east_1"
}
provider "aws" {
  region = "us-west-2"
  alias  = "us_west_2"
}
resource "aws_instance" "example_east" {
  provider      = aws.us_east_1
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = "example-east-instance"
  }
}
resource "aws_instance" "example_west" {
  provider      = aws.us_west_2
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = "example-west-instance"
  }
}
```
The alias is the attribute that helps to differentiate between multiple provider configurations of the same type. 
While adding multiple accounts for the same provider, make sure to use different aliases for each account to avoid conflicts.
It can be done by giving different profile names in the provider block for each account.
```hcl
provider "aws" {
  profile = "account1-profile"
  region  = "us-east-1"
  alias   = "account1"
}
provider "aws" {
  profile = "account2-profile"
  region  = "us-west-2"
  alias   = "account2"
}
```
While adding credentials , follow
aws configure --profile <profile_name> and then provide the access key , secret key and region details.

alias is to idesntify different provider configurations of the same type within a single Terraform configuration. This is like a variable name for the provider configuration.
profile is to specify different sets of credentials for accessing the provider's services, typically used for managing multiple accounts or roles within the same provider.

You can use variables or locals to manage provider configurations dynamically based on the environment or other factors.
and share those variables across multiple provider blocks to maintain consistency and reduce redundancy. 
## Example:
```hcl
variable "aws_region" {
  description = "AWS region to deploy resources"
  type        = string
  default     = "us-east-1"
}
provider "aws" {
  region = var.aws_region
  alias  = "default"
  profile = var.aws_region == "us-east-1" ? "account1-profile" : "account2-profile"
}
provider "aws" {
  region = var.aws_region == "us-east-1" ? "us-west-2" : "us-east-1"
  alias  = "secondary"
  profile = var.aws_region == "us-east-1" ? "account2-profile" : "account1-profile"
}
```
And share variables, locals or data sources across multiple resources with different providers to maintain consistency and reduce redundancy.
## Example:
```hcl
variable "instance_type" {
  description = "Type of AWS instance"
  type        = string
  default     = "t3.micro"
}
resource "aws_instance" "example_default" {
  provider      = aws.default
  ami           = var.ami-id
  instance_type = var.instance_type
  tags = {
    Name = "example-default-instance"
  }
}
resource "aws_instance" "example_secondary" {
  provider      = aws.secondary
  ami           = aws_instance.example_default.ami
  instance_type = var.instance_type
  tags = {
    Name = "example-secondary-instance"
  }
}





















