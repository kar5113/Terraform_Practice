Terraform notes

##### Terraform Variables
1. Variables in Terraform can be defined using the `variable` block and can be referenced using `var.<variable_name>`.
2. Variables can have default values, descriptions, and types (string, number, bool, list, map, etc.).
3. Variables can be overridden using command-line flags, environment variables, or `.tfvars` files.
4. Using variables enhances the reusability and flexibility of Terraform configurations.
5. To get the variables input from the user during runtime, we can define variables without default values.
Example:
```hcl
variable "sg_name" {
  description = "Name of the security group"
  type        = string
}
##
using commmand line  example:
terraform apply -var="sg_name=custom-sg" -var="sg_port=8080" -var='sg_cidr=["0.0.0.0/0"]'
##
using tfvars file example:
Create a file named `custom.tfvars` with the following content:
sg_name = "custom-sg"
sg_port = 8080
sg_cidr = ["0.0.0.0/0"]
Then run:
terraform apply -var-file="custom.tfvars"
## 
using environment variables example:
Set environment variables with the `TF_VAR_` prefix:
export TF_VAR_sg_name="custom-sg"
export TF_VAR_sg_port=8080
export TF_VAR_sg_cidr='["0.0.0.0/0"]'
Then run:
terraform apply 
##
the order of precedence for variable values is:
1. Command-line flags
2. Environment variables
3. `.tfvars` files
4. Default values in the configuration
5. Prompted input during runtime

#### Terraform conditions

1. Terraform supports conditional expressions using the `condition ? true_value : false_value` syntax.
2. Conditional expressions can be used to set variable values, resource attributes, and module inputs based on certain conditions.
3. This allows for dynamic configurations that can adapt based on the environment or other factors.
4. Conditional expressions can be nested for more complex logic.
## Example:
```hcl
variable "environment" {
  description = "The deployment environment"
  type        = string
  default     = "dev"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = var.environment == "dev" ? "t3.micro" : "t3.large"
  tags = {
    Name = var.environment == "dev" ? "terraform-dev-instance" : "terraform-prod-instance"
  }
}
```

#### Terraform loops
1. Terraform supports looping constructs using `for` expressions and `count` meta-argument.
2. `for` expressions can be used to create lists or maps by iterating over collections.
3. The `count` meta-argument allows for the creation of multiple instances of a resource based on a specified number.
4. Loops enhance the ability to manage multiple similar resources efficiently.
## Example using `count` expression:
```hcl
variable "instance_names" {
  description = "List of instance names"
  type        = list(string)
  default     = ["instance1", "instance2", "instance3"]
}
resource "aws_instance" "example" {
  count         = length(var.instance_names)
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = var.instance_names[count.index]
  }
}
```
## Example using `for` expression:
```hcl
variable "instance_ports" {
  description = "List of instance ports"
  type        = list(number)
  default     = [80, 443, 8080]
}
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  ingress = [
    for port in var.instance_ports : {
      from_port   = port
      to_port     = port
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```
## Example for each loop: it if for both map and set 
```hcl
variable "instance_map" {
  description = "Map of instance names to AMI IDs"
  type        = map(string)
  default     = {
    "instance1" = "ami-0abcdef1234567890"
    "instance2" = "ami-0abcdef1234567891"
    "instance3" = "ami-0abcdef1234567892"
  }
}
resource "aws_instance" "example" {
  for_each      = var.instance_map
  ami           = each.value
  instance_type = "t3.micro"
  tags = {
    Name = each.key
  }
}
```

#### Data Sources in Terraform
1. Data sources in Terraform allow you to fetch and use information from external sources or existing infrastructure.
2. They are defined using the `data` block and can reference various providers to retrieve data.
3. Data sources are read-only and do not create or modify resources.
4. They are useful for obtaining information such as AMI IDs, VPC details, or other resource attributes that are needed for resource creation.
5. Data sources can be used to reference existing resources that were not created by the current Terraform configuration.
## Example:
```hcl
data "aws_ami" "example" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
resource "aws_instance" "example" {
  ami           = data.aws_ami.example.id
  instance_type = "t3.micro"
  tags = {
    Name = "terraform-example-instance"
  }
}
```


#### Functions in Terraform
1. Terraform provides a variety of built-in functions that can be used to manipulate data and perform operations within configurations.
2. Functions can be used for string manipulation, numeric calculations, type conversions, collection operations, and more.
3. Functions enhance the flexibility and dynamism of Terraform configurations by allowing for complex logic and data transformations.
4. Functions are called using the syntax `function_name(arguments)`.
5. Functions can be nested to perform multiple operations in a single expression.
## Example:
```hcl
variable "instance_name" {
  description = "Name of the instance"
  type        = string
  default     = "terraform-example-instance"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = upper(var.instance_name)
  }
}
```
various commonly used functions:
- `upper(string)`: Converts a string to uppercase. ex: upper("hello") => "HELLO"
- `lower(string)`: Converts a string to lowercase. ex: lower("HELLO") => "hello"
- `length(collection)`: Returns the length of a collection (list, map, string). ex: length(["a", "b", "c"]) => 3
- `tolist(value)`: Converts a value to a list. ex: tolist("a,b,c") => ["a", "b", "c"]
- `tomap(value)`: Converts a value to a map. ex: tomap({key1="value1", key2="value2"}) => {key1="value1", key2="value2"}
- `tostring(value)`: Converts a value to a string. ex: tostring(123) => "123"
- `join(separator, list)`: Joins a list of strings into a single string with the specified separator. ex: join("-", ["a", "b", "c"]) => "a-b-c"
- `split(separator, string)`: Splits a string into a list of substrings based on the specified separator. ex: split("-", "a-b-c") => ["a", "b", "c"]
- `lookup(map, key, default)`: Retrieves a value from a map by key, with an optional default if the key does not exist. ex: lookup({key1="value1", key2="value2"}, "key1", "default") => "value1"
- `concat(list1, list2, ...)`: Concatenates multiple lists into a single list. ex: concat(["a", "b"], ["c", "d"]) => ["a", "b", "c", "d"]
- `format(string, args...)`: Formats a string using the specified arguments.  ex: format("Hello, %s!", "World") => "Hello, World!"
- `coalesce(value1, value2, ...)`: Returns the first non-null value from the provided arguments.  data "aws_ami" "ami" {
- `merge(map1, map2, ...)`: Merges multiple maps into a single map. ex: merge({key1="value1"}, {key2="value2"}) => {key1="value1", key2="value2"}  
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}


#### Remote state with s3 backend
1. Remote state in Terraform allows you to store the state file in a remote location, enabling collaboration and state sharing among team members.  
2. The S3 backend is a popular choice for remote state storage, providing durability, availability, and access control.
3. To configure the S3 backend, you need to specify the `backend "s3"` block in your Terraform configuration, providing details such as the S3 bucket name, key (path to the state file), region, and optional settings like encryption and locking.
4. Using remote state helps prevent conflicts and ensures that all team members are working with the most up-to-date state information.
## Example:
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "6.22.1"
    }
  }
   backend "s3" {
    bucket    = "your-remote-state-bucket"
    key       = "path/to/your/terraform.tfstate"
    region    = "us-east-1"
    encrypt   = true
    use_lockfile = true
   }
}


#### Terraform Locals
1. Locals in Terraform allow you to define named values that can be reused throughout your configuration.
2. They are defined using the `locals` block and can contain expressions, calculations, or static values.
3. Locals enhance the readability and maintainability of Terraform configurations by reducing redundancy and simplifying complex expressions.
4. Locals are evaluated only once per configuration and can be referenced using the `local.<local_name>` syntax.
5. They are useful for defining commonly used values, intermediate calculations, or complex expressions that need to be reused.
## Example:
```hcl
locals {  
  instance_name = "terraform-example-instance"
  instance_tags = {
    Environment = "dev"
    Project     = "terraform-demo"
  }
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = merge(local.instance_tags, { Name = local.instance_name })
}
```
loals vs variables:
- Variables are used to accept input values from users or external sources, while locals are used to define internal values within the configuration.
- Variables can have default values and can be overridden, whereas locals are fixed once defined and cannot be changed externally.
- Variables are typically used for configuration parameters, while locals are used for derived values or reusable expressions.
- Variables cannot reference locals, but locals can reference variables. and locals cannot reference other locals. and variables cannot reference other variables.


##### Dynamic blocks in Terraform
1. Dynamic blocks in Terraform allow you to generate multiple nested blocks within a resource or module based on a collection of values.
2. They are defined using the `dynamic` block and can iterate over lists or maps to create multiple instances of a block.
3. Dynamic blocks enhance the flexibility and reusability of Terraform configurations by allowing for variable-length configurations.
4. They are useful for scenarios where the number of nested blocks is not known in advance or can vary based on input data.
5. Dynamic blocks can include `for_each` and `content` arguments to define the iteration and the content of the generated blocks.
## Example:
```hcl
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  dynamic "ingress" {
    for_each = var.ingress_ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```


#### Provisioners in Terraform
1. Provisioners in Terraform allow you to execute scripts or commands on the target resource after it has been created or before it is destroyed.
2. They are defined using the `provisioner` block within a resource and can use different types of provisioners such as `local-exec`, `remote-exec`, `file` and others.
3. Provisioners are useful for performing configuration tasks, installing software, or running custom scripts on the resource.
4. They can be configured to run only on creation, destruction, or both using the `when` argument. By default , they run on creation.
5. Provisioners should be used sparingly, as they can introduce complexity and dependencies in the Terraform lifecycle.
6. They require proper connection settings to access the target resource, such as SSH or WinRM for remote-exec provisioners.
7. It is recommended to use configuration management tools (like Ansible, Chef, Puppet) for complex provisioning tasks instead of relying heavily on Terraform provisioners.
8. The self object can be used within provisioners to reference attributes of the resource being provisioned.
## Example:
```hcl
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file(var.ssh_private_key) // Path to your private key file
      host        = self.public_ip
    }
  }
}
```

## How to create multiple environments using terraform:
1. To create multiple environments in Terraform, you can use workspaces, directory structures, or separate state files.
2. sing .tfvars files for each environment to manage different configurations.
3. You can also use modules to encapsulate common infrastructure components and reuse them across different environments

  # Refer the terrafoem-multi-env folder for working with multople env using tfvars files and directory structure.
  # or use Terraform workspaces to manage multiple environments within a single configuration.
      Terraform workspace commands:
      - terraform workspace new <workspace_name>  # Create a new workspace
      - terraform workspace select <workspace_name>  # Switch to an existing workspace
      - terraform workspace list  # List all workspaces
      - terraform workspace show  # Show the current workspace
      - terraform workspace delete <workspace_name>  # Delete a workspace
  # Create a new workspace for each environment (e.g., dev, staging, prod) and manage state files separately for each workspace.
  # now you can use terraform.workspace in the variables , look for local.tf, variables.tf file in terraform-multiple-env folder for example.    
  # terraform.workspace can be used to dynamically set values based on the current workspace. it gives the workspace name and the remote state will be stored in separate files for each workspace.
4. By following these practices, you can effectively manage multiple environments in Terraform while maintaining consistency and reusability across your infrastructure configurations.

or Maintain different repos for each environment and modules to avoid code duplication.


#### Terraform modules.
1. Modules in Terraform are reusable, self-contained packages of Terraform configurations that can be used to encapsulate and manage related resources.
2. They allow you to organize your infrastructure code into logical components, making it easier to manage, reuse, and share.
3. Modules can be created locally within your project or sourced from external repositories, such as the Terraform Registry or GitHub.
4. Using modules promotes best practices by encouraging code reuse, consistency, and modularity in your Terraform configurations.
5. Modules can accept input variables and provide output values, allowing for parameterization and data sharing between different parts of your infrastructure.
6. To use a module, you define a `module` block in your Terraform configuration, specifying the source and any required input variables.

---- Refer the terraform-module-dev folder for example module implementation. ----

#### any changes made in the module will reflect everywhere the module is used. but needs to be re initialized using terraform init command again in the root module where it is used.

    ## Advantages of using modules:
  1. Code Reusability: Modules allow you to reuse code across different projects and environments, reducing duplication and promoting consistency.
  2. Simplified Management: By encapsulating related resources, modules make it easier to manage and maintain complex infrastructure configurations.
  3. Improved Organization: Modules help organize your Terraform code into logical components, making it easier to understand and navigate.
  4. Parameterization: Modules can accept input variables, allowing for customization and flexibility in resource configurations.
  5. Collaboration: Modules facilitate collaboration among team members by providing a standardized way to define and share infrastructure components.
  6. Versioning: Modules can be versioned, allowing you to track changes and ensure compatibility across different deployments.
  7. We can implement best practices by using modules to enforce standards and guidelines for resource configurations.
  8. changes at single place will reflect everywhere the module is used -> centralised management.



### Null resource in terraform
1. The `null_resource` in Terraform is a special resource type that does not create any actual infrastructure but can be used to trigger provisioners or manage dependencies.
2. It is often used for running scripts, executing commands, or managing resources that are not directly supported by Terraform.
3. The `null_resource` can be useful for tasks such as bootstrapping, configuration management, or orchestrating actions that need to occur during the Terraform lifecycle.
4. It can be configured with provisioners like `local-exec` or `remote-exec` to run commands on the local machine or remote instances.
5. The `null_resource` can also be used to create dependencies between resources by using the `depends_on` argument.
## Example:
```hcl
resource "null_resource" "example" {
  provisioner "local-exec" {
    command = "echo 'Hello, World!' > hello.txt"
  }
}
``` 

Now null resource is deprecated, terraform-data is the new name to achieve the same functionality.


## Terraform taint
1. The `terraform taint` command is used to mark a specific resource as "tainted," indicating that it should be destroyed and recreated during the next `terraform apply`.
2. Tainting a resource is useful when you want to force the recreation of a resource due to issues, configuration changes, or to ensure a fresh state.
3. When a resource is tainted, Terraform will plan to destroy the existing resource and create a new one in its place.  
4. The command requires the resource address as an argument to specify which resource to taint.
5. After tainting a resource, you can run `terraform plan` to see the changes that will be made, followed by `terraform apply` to execute the plan and recreate the tainted resource.
## Example:
```bash
terraform taint aws_instance.example
```















