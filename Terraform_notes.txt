Terraform notes

##### Terraform Variables
1. Variables in Terraform can be defined using the `variable` block and can be referenced using `var.<variable_name>`.
2. Variables can have default values, descriptions, and types (string, number, bool, list, map, etc.).
3. Variables can be overridden using command-line flags, environment variables, or `.tfvars` files.
4. Using variables enhances the reusability and flexibility of Terraform configurations.
5. To get the variables input from the user during runtime, we can define variables without default values.
Example:
```hcl
variable "sg_name" {
  description = "Name of the security group"
  type        = string
}
##
using commmand line  example:
terraform apply -var="sg_name=custom-sg" -var="sg_port=8080" -var='sg_cidr=["0.0.0.0/0"]'
##
using tfvars file example:
Create a file named `custom.tfvars` with the following content:
sg_name = "custom-sg"
sg_port = 8080
sg_cidr = ["0.0.0.0/0"]
Then run:
terraform apply -var-file="custom.tfvars"
## 
using environment variables example:
Set environment variables with the `TF_VAR_` prefix:
export TF_VAR_sg_name="custom-sg"
export TF_VAR_sg_port=8080
export TF_VAR_sg_cidr='["0.0.0.0/0"]'
Then run:
terraform apply 
##
the order of precedence for variable values is:
1. Command-line flags
2. Environment variables
3. `.tfvars` files
4. Default values in the configuration
5. Prompted input during runtime

#### Terraform conditions

1. Terraform supports conditional expressions using the `condition ? true_value : false_value` syntax.
2. Conditional expressions can be used to set variable values, resource attributes, and module inputs based on certain conditions.
3. This allows for dynamic configurations that can adapt based on the environment or other factors.
4. Conditional expressions can be nested for more complex logic.
## Example:
```hcl
variable "environment" {
  description = "The deployment environment"
  type        = string
  default     = "dev"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = var.environment == "dev" ? "t3.micro" : "t3.large"
  tags = {
    Name = var.environment == "dev" ? "terraform-dev-instance" : "terraform-prod-instance"
  }
}
```

#### Terraform loops
1. Terraform supports looping constructs using `for` expressions and `count` meta-argument.
2. `for` expressions can be used to create lists or maps by iterating over collections.
3. The `count` meta-argument allows for the creation of multiple instances of a resource based on a specified number.
4. Loops enhance the ability to manage multiple similar resources efficiently.
## Example using `count` expression:
```hcl
variable "instance_names" {
  description = "List of instance names"
  type        = list(string)
  default     = ["instance1", "instance2", "instance3"]
}
resource "aws_instance" "example" {
  count         = length(var.instance_names)
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = var.instance_names[count.index]
  }
}
```
## Example using `for` expression:
```hcl
variable "instance_ports" {
  description = "List of instance ports"
  type        = list(number)
  default     = [80, 443, 8080]
}
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  ingress = [
    for port in var.instance_ports : {
      from_port   = port
      to_port     = port
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```
## Example for each loop: it if for both map and set of strings
```hcl
variable "instance_map" {
  description = "Map of instance names to AMI IDs"
  type        = map(string)
  default     = {
    "instance1" = "ami-0abcdef1234567890"
    "instance2" = "ami-0abcdef1234567891"
    "instance3" = "ami-0abcdef1234567892"
  }
}
resource "aws_instance" "example" {
  for_each      = var.instance_map
  ami           = each.value
  instance_type = "t3.micro"
  tags = {
    Name = each.key
  }
}
```

#### Data Sources in Terraform
1. Data sources in Terraform allow you to fetch and use information from external sources or existing infrastructure.
2. They are defined using the `data` block and can reference various providers to retrieve data.
3. Data sources are read-only and do not create or modify resources.
4. They are useful for obtaining information such as AMI IDs, VPC details, or other resource attributes that are needed for resource creation.
5. Data sources can be used to reference existing resources that were not created by the current Terraform configuration.
## Example:
```hcl
data "aws_ami" "example" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
resource "aws_instance" "example" {
  ami           = data.aws_ami.example.id
  instance_type = "t3.micro"
  tags = {
    Name = "terraform-example-instance"
  }
}
```


#### Functions in Terraform
1. Terraform provides a variety of built-in functions that can be used to manipulate data and perform operations within configurations.
2. Functions can be used for string manipulation, numeric calculations, type conversions, collection operations, and more.
3. Functions enhance the flexibility and dynamism of Terraform configurations by allowing for complex logic and data transformations.
4. Functions are called using the syntax `function_name(arguments)`.
5. Functions can be nested to perform multiple operations in a single expression.
## Example:
```hcl
variable "instance_name" {
  description = "Name of the instance"
  type        = string
  default     = "terraform-example-instance"
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = {
    Name = upper(var.instance_name)
  }
}
```
various commonly used functions:
- `upper(string)`: Converts a string to uppercase. ex: upper("hello") => "HELLO"
- `lower(string)`: Converts a string to lowercase. ex: lower("HELLO") => "hello"
- `length(collection)`: Returns the length of a collection (list, map, string). ex: length(["a", "b", "c"]) => 3
- `tolist(value)`: Converts a value to a list. ex: tolist("a,b,c") => ["a", "b", "c"]
- `tomap(value)`: Converts a value to a map. ex: tomap({key1="value1", key2="value2"}) => {key1="value1", key2="value2"}
- `tostring(value)`: Converts a value to a string. ex: tostring(123) => "123"
- `join(separator, list)`: Joins a list of strings into a single string with the specified separator. ex: join("-", ["a", "b", "c"]) => "a-b-c"
- `split(separator, string)`: Splits a string into a list of substrings based on the specified separator. ex: split("-", "a-b-c") => ["a", "b", "c"]
- `lookup(map, key, default)`: Retrieves a value from a map by key, with an optional default if the key does not exist. ex: lookup({key1="value1", key2="value2"}, "key1", "default") => "value1"
- `concat(list1, list2, ...)`: Concatenates multiple lists into a single list. ex: concat(["a", "b"], ["c", "d"]) => ["a", "b", "c", "d"]
- `format(string, args...)`: Formats a string using the specified arguments.  ex: format("Hello, %s!", "World") => "Hello, World!"
- `coalesce(value1, value2, ...)`: Returns the first non-null value from the provided arguments.  data "aws_ami" "ami" {
- `merge(map1, map2, ...)`: Merges multiple maps into a single map. ex: merge({key1="value1"}, {key2="value2"}) => {key1="value1", key2="value2"}  
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}


#### Remote state with s3 backend
1. Remote state in Terraform allows you to store the state file in a remote location, enabling collaboration and state sharing among team members.  
2. The S3 backend is a popular choice for remote state storage, providing durability, availability, and access control.
3. To configure the S3 backend, you need to specify the `backend "s3"` block in your Terraform configuration, providing details such as the S3 bucket name, key (path to the state file), region, and optional settings like encryption and locking.
4. Using remote state helps prevent conflicts and ensures that all team members are working with the most up-to-date state information.
## Example:
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "6.22.1"
    }
  }
   backend "s3" {
    bucket    = "your-remote-state-bucket"
    key       = "path/to/your/terraform.tfstate"
    region    = "us-east-1"
    encrypt   = true
    use_lockfile = true
   }
}


#### Terraform Locals
1. Locals in Terraform allow you to define named values that can be reused throughout your configuration.
2. They are defined using the `locals` block and can contain expressions, calculations, or static values.
3. Locals enhance the readability and maintainability of Terraform configurations by reducing redundancy and simplifying complex expressions.
4. Locals are evaluated only once per configuration and can be referenced using the `local.<local_name>` syntax.
5. They are useful for defining commonly used values, intermediate calculations, or complex expressions that need to be reused.
## Example:
```hcl
locals {  
  instance_name = "terraform-example-instance"
  instance_tags = {
    Environment = "dev"
    Project     = "terraform-demo"
  }
}
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  tags = merge(local.instance_tags, { Name = local.instance_name })
}
```
loals vs variables:
- Variables are used to accept input values from users or external sources, while locals are used to define internal values within the configuration.
- Variables can have default values and can be overridden, whereas locals are fixed once defined and cannot be changed externally.
- Variables are typically used for configuration parameters, while locals are used for derived values or reusable expressions.
- Variables cannot reference locals, but locals can reference variables. and locals cannot reference other locals. and variables cannot reference other variables.


##### Dynamic blocks in Terraform
1. Dynamic blocks in Terraform allow you to generate multiple nested blocks within a resource or module based on a collection of values.
2. They are defined using the `dynamic` block and can iterate over lists or maps to create multiple instances of a block.
3. Dynamic blocks enhance the flexibility and reusability of Terraform configurations by allowing for variable-length configurations.
4. They are useful for scenarios where the number of nested blocks is not known in advance or can vary based on input data.
5. Dynamic blocks can include `for_each` and `content` arguments to define the iteration and the content of the generated blocks.
## Example:
```hcl
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Example security group"
  vpc_id      = var.vpc-id  
  dynamic "ingress" {
    for_each = var.ingress_ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
  egress = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```


#### Provisioners in Terraform
1. Provisioners in Terraform allow you to execute scripts or commands on the target resource after it has been created or before it is destroyed.
2. They are defined using the `provisioner` block within a resource and can use different types of provisioners such as `local-exec`, `remote-exec`, `file` and others.
3. Provisioners are useful for performing configuration tasks, installing software, or running custom scripts on the resource.
4. They can be configured to run only on creation, destruction, or both using the `when` argument.
5. Provisioners should be used sparingly, as they can introduce complexity and dependencies in the Terraform lifecycle.
6. They require proper connection settings to access the target resource, such as SSH or WinRM for remote-exec provisioners.
## Example:
```hcl
resource "aws_instance" "example" {
  ami           = var.ami-id
  instance_type = "t3.micro"
  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file(var.ssh_private_key)
      host        = self.public_ip
    }
  }
}
```










